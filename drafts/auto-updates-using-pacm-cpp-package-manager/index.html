<!doctype html> <html class=no-js lang=en> <head> <title>Sourcey</title> <meta charset=utf-8 /> <meta name=viewport content="width=device-width, initial-scale=1.0"/> <meta name=google-site-verification content=lC7-hHwqtiRqo7YTHc1fJ6t8ie-Hs7J4o5u3XRIF9Vw /> <link rel=alternate type="application/atom+xml" title="Atom Feed" href="/feed.xml"/> <link href="/stylesheets/app.css" media=screen rel=stylesheet /> <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-836728-7', 'sourcey.com');
      ga('send', 'pageview');
    </script> </head> <body class="page drafts drafts_auto-updates-using-pacm-cpp-package-manager drafts_auto-updates-using-pacm-cpp-package-manager_index"> <nav class=top-bar data-topbar=""> <div id=social> <a href="https://plus.google.com/+SourceyDevel"><i class="fi-social-google-plus large"></i></a> <a href="https://facebook.com/sourceydevel"><i class="fi-social-facebook large"></i></a> <a href="https://twitter.com/sourceydevel"><i class="fi-social-twitter large"></i></a> <a href="https://github.com/sourcey"><i class="fi-social-github large"></i></a> </div> <ul class=title-area> <li class=name></li> <li class="toggle-topbar menu-icon"><a href="" class=left></a></li> </ul> <section class=top-bar-section style="left: 0%;"> <ul class=left> <li class="has-dropdown not-click"><a href="/">Menu</a> <ul class=dropdown><li class="title back js-generated"><h5><a href="javascript:void(0)">Back</a></h5></li> <li><label>Wicked</label></li> <li class="has-dropdown not-click"><a href="/#projects">Projects</a> <ul class=dropdown><li class="title back js-generated"><h5><a href="javascript:void(0)">Back</a></h5></li> <li><label>Projects</label></li> <li><a href="/libsourcey">LibSourcey</a></li> <li><a href="/anionu">Anionu</a></li> <li><a href="/symple">Symple</a></li> <li><a href="/mesh">Mesh</a></li> <li><a href="/pacm">Pacm</a></li> </ul> </li> <li class=divider></li> <li><a href="/#blog">Blog</a></li> <li><a href="/archives">Archives</a></li> <li><a href="/feed.xml">Feed</a></li> <li class=divider></li> <li><a href="mailto:hello@sourcey.com">Contact</a></li> </ul> </li> <li class=divider></li> </ul> </section></nav> <header id=header> <h1 id=logo> <a title=Sourcey rel=home href="//sourcey.com"><img height=150 width=150 title=Sourcey alt=Sourcey src="/images/logo-250.png"/></a> </h1> </header> <div id=main role=main> <h1 id=auto-updates-using-pacm-c-package-manager>Auto Updates using Pacm C++ Package Manager</h1> <p>So you have coded a brilliant application, but now you need a way to keep it up-to-date, right? The good news is that C++ now has <code>pacm</code>, which works in a very similar way to popular package managers in other languages, such as <code>rubygems</code> for Ruby, and <code>npm</code> for NodeJS.</p> <p>With <code>pacm</code> you can keep all your updated binaries on the server, and the client queries the server to determine if updates are available, and proceed to update as required.</p> <p>There are a lot of factors to be considered when updating a native application, such as ABI compatability, versioning and file locks, especially if you have any kind of plugin architecture. That's the realm of the client implementation though, and outside the scope of this article, which only provides a generic solution to the issue at hand.</p> <p>You have two main options here; you can embed Pacm and build it with your application; or you can distribute the command line tool with your executable and get the external process to do the heavy lifting.</p> <h2 id=embedding-pacm-in-native-applications>Embedding Pacm in Native Applications</h2> <p>The advantage of embedding Pacm is that you get to work with the native API, which unlike the command line tool, has access to raw package data, progress updates and well … the entire C++ language.</p> <p>If you're embedding Pacm, then you can instantiate the package manager and download packages for the server like so:</p> <pre class="highlight cpp"><span class="n">pacm</span><span class="o">::</span><span class="n">PackageManager</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
<span class="n">pacm</span><span class="o">::</span><span class="n">PackageManager</span> <span class="n">pm</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
<span class="n">pm</span><span class="p">.</span><span class="n">initialize</span><span class="p">();</span>
<span class="n">pm</span><span class="p">.</span><span class="n">queryRemotePackages</span><span class="p">();</span>
</pre> <p>The next thing is to run <code>updatePackage</code> each time you run your application, or via a separate process, in order to download and install a newer version of the package if one is ever available. Note that the first time <code>updatePackage</code> is called the package will be installed if it hasn't been installed yet.</p> <pre class="highlight cpp"><span class="n">pm</span><span class="p">.</span><span class="n">updatePackage</span><span class="p">(</span><span class="s">"SomeAutoUpdatingPackage"</span><span class="p">);</span>
</pre> <p>Pretty simple right? Just the way it should be.</p> <p>Things get a little more complicated if you are updating the current binary though, due to file locks. For that you need to run Pacm from a separate binary in exactly the same way. The workflow will be as follows, with <em>app</em> representing the main application, and <em>updater</em> representing the external updater binary.</p> <p>TURN INTO PSEUDO CODE</p> <p><strong>app</strong>:</p> <ul> <li><em>app</em> starts</li> <li><em>app</em> checks for "unfinalized" updates <ul> <li><strong>True</strong>: if "unfinalized" updates exist the <em>app</em> exits and the <em>updater</em> is run </li> <li><strong>False</strong>: continue execution… </li> </ul> </li> <li><em>app</em> checks if a newer version is available from the server <ul> <li><strong>True</strong>: <em>app</em> installs the newer packages <ul> <li><strong>True</strong>: continue execution… </li> <li><strong>False</strong>: the package installation fails on "finalizing" because of a file lock (ie. trying to overwrite the current binary) <ul> <li>the <em>app</em> exits and the <em>updater</em> is run </li> </ul> </li> </ul> </li> <li><strong>False</strong>: continue execution… </li> </ul> </li> </ul> <p><strong>updater</strong>:</p> <ul> <li><em>updater</em> waits for the <em>app</em> to exit and finalizes the installation</li> <li><em>updater</em> exists and runs the <em>app</em></li> </ul> <p>The next thing would be to download the auto-updating package, which we will call <code>SomeAutoUpdatingPackage</code> from the server when the user first installs your software: The basic workflow for auto updates is as follows: * Remote </p> <p>pm.updateAllPackages();</p> <h2 id=updating>Updating</h2> <p>With <code>pacm</code> it's easy to query the server and automatically update a local package set with one command from the binary</p> <pre class="highlight shell">pacm --endpoint https://someserver.com --uri /packages.json --update
</pre> <p>source code to query and update all your installed packages would look like this:</p> <p>Bear in mind that </p> <p>For Auto updates </p> <p>Alternatively, you can just call the binary from your existing application. </p> <p>If the exit code is <code>0</code>, then the command was run successfully.</p> <p>. to do the heavy lifting without complicating your application.</p> <p>call </p> <p>… two options, embed and redist ..</p> <p>it is the job of the client implementation to factor these </p> <p>If we were using a different language this would be easy. In Ruby we have <code>rubygems</code>, and NodeJS we have <code>npm</code>, but native C++ has come up short until <code>pacm</code>.</p> <p>With <code>pacm</code> it's easy to query the server and automatically </p> <p>keeps installed package manifests in JSON format on the local filesystem</p> <p>This is a huge factor for native applications where things like ABI compatibility, versioning and file locks need to be considered, especially if you provide any kind of plugin architecture.</p> <p>Over the last few years it's been interesting to watch most of the big companies on the internet transition from optional updates to automatic updates. Gone are the days of the old fasioned "Do you want to update to version X?" dialog, now days what we tend to see is "You are now running version X" instead. Since this post isn't about the moral implications of this transition, so I'll refrain from a rant, instead I'll show you how we implement this in out own applications easily and efficiently with the help of a little peice of open source software called <code>Pacm</code>.</p> <p>Some of you may be farmiliar with our project, Anionu. Anionu has a native application called Spot, which is essentially a modular native plugin system that communicates with the Anionu API. In the case of Spot, auto updates are a must to ensure security fixes are always applied, and compatability is maintained with the current REST API. None of the existing package managers out there met our requirements, they were all too convoluted or dependeny heavy, so we build <code>Pacm</code>.</p> <p>In the example below</p> <p>Spot consumes the Anionu API</p> <p>For a native appliclation</p> </div> <footer id=footer> <p> As with all business minded artists, we have fought the inevitable battle of conformity vs expression, and have emerged victorious with sanity intact to plunder the digiverse in search of new and interesting challenges. For more information, or a quote, drop us an email and tell us what you're working on. </p> <p> &copy;2014 Sourcey <p> </footer> </body> </html> <script src="/javascripts/all.js"></script>