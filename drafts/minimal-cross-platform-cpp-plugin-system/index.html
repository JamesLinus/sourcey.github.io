<!doctype html> <html class=no-js lang=en> <head> <title>Sourcey</title> <meta charset=utf-8 /> <meta name=viewport content="width=device-width, initial-scale=1.0"/> <meta name=google-site-verification content=lC7-hHwqtiRqo7YTHc1fJ6t8ie-Hs7J4o5u3XRIF9Vw /> <link rel=alternate type="application/atom+xml" title="Atom Feed" href="/feed.xml"/> <link href="/stylesheets/app.css" media=screen rel=stylesheet /> <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-836728-7', 'sourcey.com');
      ga('send', 'pageview');
    </script> </head> <body class="page drafts drafts_minimal-cross-platform-cpp-plugin-system drafts_minimal-cross-platform-cpp-plugin-system_index"> <nav class=top-bar data-topbar=""> <div id=social> <a href="https://plus.google.com/+SourceyDevel"><i class="fi-social-google-plus large"></i></a> <a href="https://facebook.com/sourceydevel"><i class="fi-social-facebook large"></i></a> <a href="https://twitter.com/sourceydevel"><i class="fi-social-twitter large"></i></a> <a href="https://github.com/sourcey"><i class="fi-social-github large"></i></a> </div> <ul class=title-area> <li class=name></li> <li class="toggle-topbar menu-icon"><a href="" class=left></a></li> </ul> <section class=top-bar-section style="left: 0%;"> <ul class=left> <li class="has-dropdown not-click"><a href="/">Menu</a> <ul class=dropdown><li class="title back js-generated"><h5><a href="javascript:void(0)">Back</a></h5></li> <li><label>Wicked</label></li> <li class="has-dropdown not-click"><a href="/#projects">Projects</a> <ul class=dropdown><li class="title back js-generated"><h5><a href="javascript:void(0)">Back</a></h5></li> <li><label>Projects</label></li> <li><a href="/libsourcey">LibSourcey</a></li> <li><a href="/anionu">Anionu</a></li> <li><a href="/symple">Symple</a></li> <li><a href="/mesh">Mesh</a></li> <li><a href="/pacm">Pacm</a></li> </ul> </li> <li class=divider></li> <li><a href="/#blog">Blog</a></li> <li><a href="/archives">Archives</a></li> <li><a href="/feed.xml">Feed</a></li> <li class=divider></li> <li><a href="mailto:hello@sourcey.com">Contact</a></li> </ul> </li> <li class=divider></li> </ul> </section></nav> <header id=header> <h1 id=logo> <a title=Sourcey rel=home href="//sourcey.com"><img height=150 width=150 title=Sourcey alt=Sourcey src="/images/logos/sourcey-250x250.png"/></a> </h1> </header> <div id=main role=main> <h1 id=minimal-cross-platform-c-plugin-system>Minimal Cross-platform C++ Plugin System</h1> <p>When designing a plugin management system for C++, there are some important factors and gotchas to consider, such as binary compatibility, strict versioning, and interprocess memory management. Sounds like fun right? Well, if you get it wrong then it sure as hell won't be, but if you get it right then it's really not so bad.</p> <h2 id=abi-and-binary-compatibility>ABI and Binary Compatibility</h2> <p>The first issue to address is the <a href="//en.wikipedia.org/wiki/Application_binary_interface">ABI (binary compatibility)</a>. Unless you want a suicide inducing customer support nightmare on your hands, then stick to this one simple rule: only ever pass POD (plain old data) data types between process boundaries.</p> <p>This means no passing STL containers and other complex types between the application and plugins, and no throwing any exceptions either. "But this is C++!!", you cry in anguish, and who could blame you? In this case all we can do is bite our collective tongues and accept that that's the way it is. The reason for this is that the standard libraries vary from compiler to compiler, and platform to platform, so if you really must use complex types then you will need to ensure that plugins are compiled on exactly the save version of exactly the same compiler using identical system libraries. In short, screw that.</p> <p>There are alternatives, such as embedding the standard libraries in your project using <a href="//www.stlport.org">STLport</a> or similar to ensure consistency between platforms, but why bother? It's overkill. The easiest alternative it just to pass a <code>void*</code> or a <code>char*</code> buffer and encode/decode it as required across the process boundary.</p> <p>The method we've been using recently is actually quite simple. Let's say that on the plugin side we have a single method which accepts arbitrary commands from the application. Commands are namespaced using a <a href="//en.wikipedia.org/wiki/Representational_state_transfer">REST</a> style interface like so <code>resource:action</code>, and the data buffer contains either a JSON encoded message which for representing and converting to an STL container such a <code>std::vector</code> or <code>std::map</code> to pass to the internal API, or it may just be a raw data buffer that can be used directly.</p> <p>Take the following code for example:</p> <pre class="highlight cpp"><span class="n">bool</span> <span class="nf">onCommand</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>    
    <span class="n">try</span> <span class="p">{</span>
        <span class="c1">// Handle a JSON encoded options hash
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">"options:set"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   
            <span class="n">json</span><span class="o">::</span><span class="n">Value</span> <span class="n">root</span><span class="p">;</span>
            <span class="n">json</span><span class="o">::</span><span class="n">Reader</span> <span class="n">reader</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reader</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>          
                <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Invalid JSON format: "</span> <span class="o">+</span> <span class="n">reader</span><span class="p">.</span><span class="n">getFormatedErrorMessages</span><span class="p">());</span>
                
            <span class="c1">// Do something with JSON data here...
</span>        <span class="p">}</span>

        <span class="c1">// Handle raw file data
</span>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">"file:write"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">(</span><span class="s">"test.bin"</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">ofs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="o">|</span><span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ofs</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span>
                <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Cannot write to output file: "</span> <span class="o">+</span> <span class="n">path</span><span class="p">);</span>
            <span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
            <span class="n">ofs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// Handle unknown commands
</span>        <span class="k">else</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Unknown command"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">exc</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Catch exceptions here and return false.
</span>        <span class="c1">// You could set a lastError string here which is exposed to
</span>        <span class="c1">// the application that returns the error message as a char*.
</span>        <span class="c1">// See the full example for details.
</span>        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">exc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre> <p>Using this method you're free to implement almost any kind of functionality without having to add new methods and break the API each time you roll out a new feature. Nice!</p> <h2 id=interprocess-memory-handling>Interprocess Memory Handling</h2> <p>One other simple rule that should be adhered to when building your plugin system is: any memory allocated by a process should be deallocated by the same process. </p> <p>Let's say the application asks the plugin to allocate and return a <code>char*</code> buffer, and then proceeds to delete the buffer when it's done with it. Honk! Big no no, you're asking for a crash.</p> <p>Two examples, this is bad:</p> <pre class="highlight cpp"><span class="n">bool</span> <span class="nf">askPluginForSomeSugar</span><span class="p">(</span><span class="n">Plugin</span><span class="o">*</span> <span class="n">plugin</span><span class="p">)</span>
<span class="p">{</span>    
    <span class="c1">// allocate buffer of some sort
</span>    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">plugin</span><span class="o">-&gt;</span><span class="n">gimmeSomeSugarBaby</span><span class="p">();</span>

    <span class="c1">// do something cool with data
</span>
    <span class="c1">// don't manage memory data allocated by the other process!
</span>    <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre> <p>This is good:</p> <pre class="highlight cpp"><span class="n">bool</span> <span class="nf">askPluginForSomeSugar</span><span class="p">(</span><span class="n">Plugin</span><span class="o">*</span> <span class="n">plugin</span><span class="p">)</span>
<span class="p">{</span>    
    <span class="c1">// allocate buffer of some sort
</span>    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">plugin</span><span class="o">-&gt;</span><span class="n">gimmeSomeSugarBaby</span><span class="p">();</span>

    <span class="c1">// do something cool with data
</span>
    <span class="c1">// hand the pointer back to the plugin to be deallocated
</span>    <span class="n">plugin</span><span class="o">-&gt;</span><span class="n">putSugarBackInTheBowl</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre> <h2 id=the-plugin-api>The Plugin API</h2> <p>The plugin API header defined the virtual plugin class, and a macro which exports a structure containing the plugin description, version information, and an initialization functor.</p> <p>A completely minimal plugin API using our design template would look something like this:</p> <pre class="highlight cpp"><span class="c1">// Virtual plugin class
</span><span class="k">class</span> <span class="nc">IPlugin</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">IPlugin</span><span class="p">()</span> <span class="p">{};</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IPlugin</span><span class="p">()</span> <span class="p">{};</span>

    <span class="k">virtual</span> <span class="n">bool</span> <span class="n">onCommand</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// Define the ABI version
// This value is incremented whenever there are ABI breaking changes
</span><span class="cp">#define SCY_PLUGIN_ABI_VERSION 1
</span>    
<span class="cp">#ifdef WIN32
# define SCY_PLUGIN_EXPORT __declspec(dllexport)
#else
# define SCY_PLUGIN_EXPORT // empty
#endif
</span>
<span class="c1">// Define a type for the static function pointer
</span><span class="n">SCY_EXTERN</span> <span class="k">typedef</span> <span class="n">IPlugin</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">GetPluginFunc</span><span class="p">)();</span>

<span class="c1">// Plugin details structure that's exposed to the application
</span><span class="k">struct</span> <span class="n">PluginDetails</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">abiVersion</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fileName</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">className</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pluginName</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pluginVersion</span><span class="p">;</span>
    <span class="n">GetPluginFunc</span> <span class="n">initializeFunc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SCY_STANDARD_PLUGIN_STUFF \
    SCY_PLUGIN_ABI_VERSION,       \
    __FILE__
</span>
<span class="cp">#define SCY_PLUGIN(classType, pluginName, pluginVersion) \
  extern "C" {                                           \
      SCY_PLUGIN_EXPORT scy::IPlugin* getPlugin()        \
      {                                                  \
          static classType singleton;                    \
          return &amp;singleton;                             \
      }                                                  \
      SCY_PLUGIN_EXPORT scy::PluginDetails exports =     \
      {                                                  \
          SCY_STANDARD_PLUGIN_STUFF,                     \
          #classType,                                    \
          pluginName,                                    \
          pluginVersion,                                 \
          getPlugin,                                     \
      };                                                 \
  }
</span>
</pre> <h2 id=defining-the-plugin>Defining the Plugin</h2> <h2 id=instantiating-the-plugin>Instantiating the Plugin</h2> <p>The way to instantiate your plugin is by using my old friend, macros! Using macros we can export the plugin description, version and an initialization functor as a structure. This way be can do some important runtime checks before safely instantiating the plugin.</p> <p>The way to instantiate your plugin is by using my old friend, macros! Using macros we can export the plugin description, version and an initialization functor as a structure. This way be can do some important runtime checks before safely instantiating the plugin.</p> </div> <footer id=footer> <p> As with all business minded artists, we have fought the inevitable battle of conformity vs expression, and have emerged victorious with sanity intact to plunder the digiverse in search of new and interesting challenges. For more information, or a quote, drop us an email and tell us what you're working on. </p> <p> &copy;2014 Sourcey <p> </footer> </body> </html> <script src="/javascripts/all.js"></script>